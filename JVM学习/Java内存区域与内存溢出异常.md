### Java内存区域与内存溢出异常

##### 1. 运行时数据区

| 区域       | 是否线程私有 | 描述                                       | 抛出的异常                                    |
| -------- | ------ | ---------------------------------------- | ---------------------------------------- |
| 程序计数器    | 是      | 可以看作是当前线程所执行的字节码的行数的计数器，字节码解释器根据程序计数器选取下一条要执行的，每个线程都有自己的程序计数器，当一个线程重新获取cpu时间片段的时候，根据程序计数器来恢复到正确的位置。 | 无                                        |
| Java虚拟机栈 | 是      | 也是每个线程私有的，每个方法执行的时候，会创建一个栈帧来存放**局部变量表**。存放各种基本数据类型和对象的引用 | 线程请求的栈深度大于最大的栈深度：**StackOverflowError**(递归调用出现)或者在扩展时无法申请到内存**OutOfMemoryError**(弄出太多线程是出现，因为一个进程能申请的内存大小是有限制的，所以太大的话会申请不到。) |
| 本地方法栈    | 是      | 类似于java虚拟机栈                              | 类似于java虚拟机栈                              |
| Java堆    | 否      | Java虚拟机堆是线程共享的，存放对象实例，可以通过 -Xms,-Xmx来调整堆大小 | 无法扩展的时候抛出OutOfMemoryError                |
| 方法区      | 否      | 也是各个线程共享的，储存虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。常量池也是其中的一部分 | 常量池无法再申请到内存的时候会抛出OutOfMemoryError异常      |



##### 2.一个对象的结构

> 一个对象结构包括:**对象头**(MarkWord + 类型指针) + **实例数据** + **对齐填充**

- 对象头

  对象头包括 **MarkWord** + **类型指针** + **数组长度** (如果是一个数组对象)

  **类型指针**指的是指向这个对象所属的类类型。

  **MarkWord**在32位系统和64位的系统上大小分别是32bit和64bit，但是这个长度是不够储存对象的数据的，只是可以根据是否处于锁状态复用自身的结构，它包含的信息(32bit)如下：

  ​

| 储存内容           | 大小    |                                          |
| -------------- | ----- | ---------------------------------------- |
| 对象哈希值          | 25bit |                                          |
| 对象分代年龄         | 4bit  |                                          |
| 指向锁记录的指针(可复用的) |       |                                          |
| 指向重量级锁的指针      |       |                                          |
| 偏向线程ID         |       |                                          |
| 储存锁标志位         | 2bit  | 01未锁定;00轻量级锁定;10膨胀(重量级锁定);11GC标记;01(可偏向) |

| markword 标记位      | 解释                                       |
| ----------------- | ---------------------------------------- |
| 01                | 未锁定                                      |
| 01 + hashcode = 0 | 可偏向 未锁定，markword的**hashcode**位置记录偏向线程的**thread-id** |
| 00                | 轻量级锁，markword的其他位置记录占有线程的**lock record**的指针 |
| 10                | 重量级锁，markword的其他位置记录占有线程的**lock record**的指针 |
| 11                | GC标记，其他位置的信息都不要了，等着回收吧辣鸡                 |

ps:具体锁的优化见[Java锁相关](./线程安全与锁优化.md)

- 对齐填充

  HotSpot的自动内存管理系统要求对象的起始地址必须是8字节的整数倍。



- 对象的访问定位

> **java虚拟机栈**上的引用如何指向堆上的对象地址
>
> 1. 使用句柄的方式，维护一个句柄池，句柄池再指向堆，优点在于垃圾回收的时候不用去修改栈上的reference，但是获取一个对象需要两次指针;
> 2. 直接指针方式，速度更快，hotspot使用这种方式。
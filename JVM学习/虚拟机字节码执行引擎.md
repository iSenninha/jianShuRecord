### 虚拟机字节码执行引擎

> 执行引擎在执行字节码的时候，可能会通过解释的方式或者是即时编译的方式执行



##### 1.运行时栈帧结构

| 当前线程     | 对应解释                                     | 线程1  | 线程n  |
| :------- | ---------------------------------------- | ---- | ---- |
| ---当前栈帧  | 支持虚拟机进行方法调用和方法执行的数据结构，栈帧里包含以下储存部分        |      |      |
| ---局部变量表 | 局部变量表以变量槽**slot**为基本单位，存放**基本数据类型**和**引用**，并且局部变量表是会被**复用**的，比如变量a已经超过了作用范围，然后这个位置可能会被接下去新分配的变量b复用。并且局部变量表是**标记清除法GC Roots的一部分**，另外一部分是**全局静态变量** |      |      |
| ---操作数栈  | **LIFO**栈，执行操作的时候，会有各种数据入栈和出栈，栈帧间有一部分的操作数栈是共享的，这是为了在方法间调用共用一些数据。 |      |      |
| ---动态连接  | 每一个栈帧都包含指向运行时**常量池**中该栈帧所属方法的引用，为了支持方法调用过程中的动态连接。(具体看**2**的解析) |      |      |
| ---返回地址  | 当前栈帧出栈，恢复上层方法的局部变量表和操作数栈，如果有返回值，把返回值压入**操作数栈**，调整PC计数器的值指向方法调用指令的后面一条指令。 |      |      |
| ---栈帧n   |                                          |      |      |
|          |                                          |      |      |



##### 2.方法调用

> Class方法在编译过程中不包含**连接**这一部分，所有的方法调用都只是符号引用，所有方法调用可能要在类加载甚至到运行期间才能确定目标方法的实际调用。

​	**1.**静态调用(解析)

​	   静态调用，Java里**static**方法和**final**方法是静态调用的，是在编译期就确定了会连接哪个方法。**符号引用**转变成了**直接引用**。

​	**2.**静态分派

​	    先来这个概念：

```
Object obj = new String();
这里obj的静态类型是Object，String是实际类型
然后如果这个时候有两个重载方法，一个参数是String，另外一个是Object，
调用xxx(obj);
这个时候实际上调用的是参数为Object的那个方法
```

 	所以**静态分派**也是在编译期间就确定的，强调的是**重载方法**的“静态解析”，而**解析**是用在不能被重载的方法上，当然，静态方法也能"重载"。。

​	**3.**动态分派

​	   1.找到操作数栈顶的第一个元素对应的堆里的对象的实际类型;

​	   2.然后从堆里指向的方法区里的对应类C，从这个类里找到对应的这个方法;

​	   3.如果**2**没找到，继续从C自底向上搜索合适的方法(从子类--->到父类)
### 线程安全与锁优化

> 当多线程访问的时候，不用调用者考虑任何同步或者是锁相关的事宜，调用者都能得到正确的结果，那么就是线程安全的。



- Java中的线程安全

  1. 不可变(Immutable)

     不可变状态的成员变量一定是线程安全的，比如String的成员变量char[]数组就是final类型的，所以每次操作后对原来的对象都不会造成影响，而是返回一个新的对象给调用者。

  2. 绝对线程安全

     指的是不管并发如何操作，都能正确地执行操作，事实上，很多标注线程安全的类都不是绝对线程安全的

  3. 相对线程安全

     如Vector，相对是指即使对应方法加了锁，但是在一个线程在删除，一个线程在遍历输出的情况下，仍然可能会出现数组越界。

  4. 线程兼容

     在外部同步的帮助下，可以在并发环境下安全地使用

  5. 线程对立

     就是无论在调用端如何同步，都可能会出现问题。



- 阻塞同步
  - Synchronized锁原理
    1. Synchronized同步块前后会在字节码里插入**monitorenter**和**monitorexit**;
    2. 执行**monitorenter**执行的时候，首先检查是否获取到了监视器状态，如果是，往计数器+1，所以同一个线程是可以多次获取锁的，否则的话，**阻塞**。
    3. 由于Java的线程是轻量级内核线程来实现的，所以处于**阻塞**状态的线程唤醒或者进入**阻塞**都需要**内核**调度，这个过程是很耗费时间的，所以Synchronized是一个**重量级**操作，但是虚拟机会通过编译优化取消锁或者**自旋**等待避免频繁切换到核心态中。


  - JUC包下锁的原理
    1. 一个volatile变量记录状态，一个等待(**waiting**)队列;
    2. 存在竞争的线程加入等待队列(此时线程处于**waiting**状态)，然后等待被唤醒。


  - Synchronized与J.U.C包下锁的区别

    > 1. Synchronized是通过原生的锁的方式来实现锁的，而J.U.C包下的锁是在API层面实现的，这是区别之一;
    > 2. 另外s锁在获取锁的过程中是处于**阻塞**，而JUC的锁是处于**Waiting**的，这也是两者的一个区别;
    > 3. 两者的性能在上古JDK中是juc强，但是随着后期的jdk优化，s锁的性能也不相上下了。所以除非是在功能上由需求，还是使用s锁比较简单和直观。



- 非阻塞同步

  CAS操作，自旋操作，调用平台相关的机器原语，直到操作成功才返回。



- 锁优化(虚拟机层的优化)

  1. 自旋锁

     上面说了，频繁切入内核态给并发性能带来了很大的压力，所以当竞争产生时，虚拟机会让cpu空转来等待获取锁，当然这个空转的次数是有限的， 不然就白白浪费了cpu的资源。

     可以通过： **-XX:+UseSpinning** 指定自旋次数。

     jdk1.6引入了自适应自旋锁。

  2. 锁消除

     基于**逃逸分析**来实现锁消除。比如一个对象是不可能逃逸出一个方法的情况下，把它当栈数据处理，去除不必要的锁。

  3. 锁粗化

     如果多个**细锁**连续存在，虚拟机判断后会把它当作同一个锁，这就是锁粗化

  4. 偏向锁

     当一个对象处于初始化(hashcode为0)未锁定状态下第一次被一个线程请求锁的时候，会把**markword**中**hashcode**的位置存放当前申请锁的**线程id**。cas操作成功的话，就获取到了偏向锁，此时标记位为**01**

     这个时候，如果**markword**一直没变化的情况下，相同线程的释放获取锁**不用**再去执行cas操作或者其他的，这就是**偏向**。

     如果这个时候另外的线程去获取锁，偏向模式结束，开始变成**轻量级锁**，标记位为**01**(偏向和未锁定标记位都是01，但是处于可偏向状态的hashcode位置是全0)或者**00**。

  5. 轻量级锁

     当一个对象处于未被锁定且不可偏向的状态时候标记位为**01**，把**markword**存放在栈帧**lock record**中，然后尝试**cas**操作把markword的**hashcode**部分更新为指向**lock record**的指针中，如果操作成功，那么进入了偏向模式。

     如果操作失败，首先markword的指针是否指向当前线程的**lock record**中，如果是，正常获取锁，否则的话，将**markword**标记位置为**10**，膨胀为重量级锁

     退出锁的时候，需要把**lock record**中的副本cas操作给**markword**，如果没有膨胀为**重量级锁**，操作成功，反之有其他线程在等待，要唤醒其他的线程。

     如果不存在竞争的情况下，避免了重量级锁的**互斥量**的开销，但是，如果在竞争激烈的情况下，由于还多了cas操作，性能反而下降了。

     ​

     > 所以：
     >
     > 1. 偏向锁只可能偏向一个线程，一旦膨胀为轻量级锁后不能再偏向，只在获取偏向的时候要cas操作，其他时候直接进入;
     > 2. 轻量级锁也是，如果膨胀为重量级后也无法回去，无竞争情况下用cas操作来同步;
     > 3. 重量级锁直接用互斥量来同步;
### Java内存模型

> Java内存模型主要解决三个问题：
>
> 1. 原子性;
> 2. 内存可见性;
> 3. 有序性。

- 主内存与工作内存

> 主内存指的是RAM，对应Java的堆栈，对应的就是**堆**中的对象实例。
>
> 工作内存是线程私有的，对应的是高速缓存，寄存器，RAM，对应的是**虚拟机栈**里的某些部分。



- 主内存与工作内存间的交互

> 主内存和工作内存间的交互，延伸一下，就是不同的工作内存之间的交互，也就是线程之间的通信了。
>
> 定义有一系列的规则确保交互操作的正确性。

|   操作   | 说明                                       | 说明                                       | 对应的上层操作                                  |
| :----: | ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |
|  lock  | 作用于主内存，表明这个变量被某个线程独占                     | lock的时候会把**工作内存**当前变量清空，重新从**主内存**load   | synchronized，final，volatile都会执行这些，解决了多年的困扰 |
| unlock | 作用于主内存，表明这个变量被解除独占                       | unlock的时候会把**工作内存**store,write回**主内存**   |                                          |
|  read  | 作用于主内存，它把一个变量的值从主内存传输到线程的工作内存中，供下一步load使用 | read和load，store和write成对出现                |                                          |
|  load  | 作用于工作内存，把read操作获取到的变量放入工作内存的变量**副本**中    |                                          |                                          |
|  use   | 作用于工作内存，将工作内存中的变量传入执行引擎                  |                                          |                                          |
| assign | 作用于工作内存，把执行引擎得到的值赋值给工作内存的变量**副本**        |                                          |                                          |
| store  | 作用于工作内存，把工作内存的变量副本传递给主内存，以便下一步write使用    | store之前必须经过load和assign，即必须在共享内存初始化，且改变后才需要写入共享内存里 |                                          |
| write  | 作用于主内存的变量，把从上一步store操作从工作内存获取到的变量放回主内存   |                                          |                                          |
|        |                                          |                                          |                                          |



- Volatile的作用

  1. 保证内存可见性

     保证工作内存能及时刷新回主内存，并且其他线程能及时从主内存获取最新的值。

  2. 禁止重排序

     ```
     volatile int a = 0;
     a = 13;
     //这里会插入一个内存屏障,并且把这个值从工作内存刷新回共享内存
     int b = 10;//所以这个为屏障，后面的指令无法重排序到上面
     ```

  ​

- Happen-Before原则

  1. 程序次序规则

     在一个线程内，书写于前面的代码先于后面的代码执行

  2. 程序锁定规则

     同一个锁，lock先于unlock

  3. volatile规则

     一个线程内，volatile的写操作优先于读操作

  4. 线程启动规则

     一个线程内，start()先于线程内的任何操作

  5. 线程终止规则

     一个线程内，thread.join()，thread.isAlive()等检测操作先行发生于终止操作

  6. 线程中断规则

  7. 对象终结原则

  8. 传递性

     A先于B，B先于C，A先于C

  > Happen-Before 强调的是实际程序运行的结果，在这个过程中的顺序可能会被编译器优化，只要不违反最终的结果即可。
### A*搜寻算法

> **A\*搜索算法**，俗称**A星算法**。这是一种在图形平面上，有多个[节点](https://zh.wikipedia.org/wiki/%E7%AF%80%E9%BB%9E)的[路径](https://zh.wikipedia.org/wiki/%E8%B7%AF%E5%BE%84)，求出最低通过[成本](https://zh.wikipedia.org/wiki/%E6%88%90%E6%9C%AC)的[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95)。常用于游戏中的NPC的移动计算，或[在线游戏](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F)的BOT的移动计算上。
>
> 该算法综合了Best-First Search和[Dijkstra算法](https://zh.wikipedia.org/wiki/Dijkstra%E7%AE%97%E6%B3%95)的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径（基于评估函数）。([维基百科](https://zh.wikipedia.org/wiki/A*%E6%90%9C%E5%AF%BB%E7%AE%97%E6%B3%95))
>
> 估算函数为：
>
> **f(n) = g(n) + h(n)**
>
> **f(n)**指的是整个寻路过程中的动态估值总长度
>
> **h(n)**指寻路过程**中途**某个节点到终点的距离
>
> **g(n)**指寻路过程中起点到当前结点的距离



- 整个算法的步骤如下：

  1. 从起始点出发(当前结点)，计算周围九个格子的到终点的距离，先约定**对角**的距离是1.4，**横向纵向**移动是1，然后分别计算**g(n)**，**h(n)**，**f(n)**，加入**openlist**

  2. 从以上**openlist**移除最小的**f(n)**，加入**closelist**，并且把当前的被选入**closelist**的结点的父节点指向**出发节点**，然后设置**当前节点**为前面被**选中的那个节点**(当前节点都在**closelist**中)

     ​

     **以上是从起始位置开始搜寻的第一步，并没有普遍性，以下的说明才是具有普遍性的。**

     ​

  3. 从**当前结点**出发，扫描周围的不是障碍物以及不在close中的结点的结点，分别计算g(n)，h(n)，f(n)，这个时候要注意，如果扫描的那个结点存在于**openlist**里，并且恰巧它就是这一步的**最小f(n)**结点(**被选中结点**)，那么需要比较是否此次计算的**g(n)**和上次计算的**g(n)**的大小关系，如果此次**g(n)**更小，那么被选中结点的父结点就是**当前节点**，否则被**选中结点的父结点不变**。这种情况出现在此路不同绕路或者对角线的情况下。

  4. 还有一个问题就是，如果遇到相同的**f(n)**的时候，选一个就行，因为不管选哪个最后的距离都是相同的。

     **重复步骤3**

  5. 最后，当**closelist**包含了终点的时候，从终点的父节点反向遍历，就得到了一条路径啦。



> 不用担心此路不通的情况，不通的话会绕回通的地方，这个时候**closelist**的值可能会比较大，但是最后反向遍历的时候还是按照父结点最优路线来搜索路线的。

- 参考[A星](http://blog.csdn.net/hitwhylz/article/details/23089415)


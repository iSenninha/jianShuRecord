### lock monitor
在Java应用中，锁竞争是否激烈，可以简单通过**jstack**导出的堆栈数据，简单查看线程堆栈的位置，感性判断是否锁竞争严重。
下面通过统计数据得出是否锁竞争激烈的结论。


#### 1.锁竞争的宏观表现
当一个线程无法取得锁的时候，线程会挂起，直到下次唤醒再次尝试获取锁，这个过程会导致操作系统的**让步式上下文切换**(volunteer context switch)。
一次让步式上下文切换大概需要**8w**个时钟周期，代价是很高的。对于Java应用来说，如果一个应用的上下文切换占用达到了**5%**，表明锁竞争已经非常激烈。
计算这个比例系数的公式是：
> 让步式上下文切换数 * 每次切换消耗的时钟周期 / cpu每秒时钟周期 * 100%

#### 2.监控非抢占式上下文切换
在Linux下，监控上下文切换相关可以通过**pidstat**命令进行统计，这是在**sysstat**工具包里的一个工具。
```
pidstat -w -I -p pid interval

Linux 4.9.0-6-amd64 (senninha) 	2018年09月01日 	_x86_64_	(4 CPU)

20时56分09秒   UID       PID   cswch/s nvcswch/s  Command
20时56分11秒  1000      1392      9.50      0.00  python2
```
我这台电脑是四核，主频是:
```
model name	: Intel(R) Core(TM) i5-4200U CPU @ 1.60GHz
```
然后计算：
```
9.50 / 4 * 8w / 1.60g * 100% = 0.011%
```
所以这个应用是不存在锁竞争。

#### 3.监控抢占式上下文
上面所说的是让步式上下文切换，是因为锁竞争导致的主动让出cpu执行时间片段，而**抢占式上下文切换**(Involunteer context switch)是因为线程的cpu时间
片段耗尽或者是被其他优先级更高的线程抢占了执行时间，而导致的上下文切换。
监控抢占式上下文切换也可以通过**pidstat**命令监控：
```
pidstat -w -I -p pid interval
Linux 4.9.0-6-amd64 (senninha) 	2018年09月01日 	_x86_64_	(4 CPU)
										抢占式							
20时56分09秒   UID       PID   cswch/s nvcswch/s  Command
20时56分11秒  1000      1392      9.50      0.00  python2
```

#### 4.pidstat的其他用法
- 堆栈-s
- 内存 -r
- 上下文切换 -w
- cpu使用 -u
- 线程数量，fd数量 -v

### protobuf的编码方式
> 其实这篇文章基本就算翻译[Encoding|Protocol Buffer](https://developers.google.com/protocol-buffers/docs/encoding)


#### 一个简单的示例
```
message Test1 {
	optional int32 a = 1;
}
```
我们把a设置为150，进行编码，输出，会发现结果是这样一个字节：
```
08 96 01
```
三个字节，小于int型本身四个字节。但是这三个字节代表什么呢？

#### 变长编码(Varints)
为了明白上述的简单编码，首先需要理解变长编码(Varints)。v是一种使用一个或多个字节序列化整形数据的算法。越小的数字占用的字节越少。
varints里的每一个字节都有msb(most significant bit,即最高位)，除了最后一个字节，这是用来标明后续是否还有更多的字节(UTF-8也是类似)。每一个字节的低7位作为一组用来储存2进制编码的数据，低权重的组在前面(小端都要用烧死...)

所以，如果是单字节的数字，比如1，不存在msb：
```
0000 0001
```

如果是300的话,编码后:
```
1010 1100 0000 0010
```
如何解码出这是300呢？首先，丢弃每一个字节中的msb，因为这是用来指明是否抵达了本个数据的边界。很明显，首字节是的msb是1,表明还有后续字节，第二个字节的msb就是0了，表明已经到达了边界:
```
1010 1100 0000 0010
 010 1100  000 0010
```
然后，记住，这货是小端，所以，我们要翻转一下：
```
 010 1100  000 0010
 000 0010  010 1100
 
 ->  00000100101100
     256 + 32 + 8 + 4 = 300
```

#### 消息结构体
正如你看到的，一个pb是协议是由一系列的key-value对组成的。协议的版本仅使用结构体成员的数字作为key，每一个成员的名字和类型只取决于对应消息的定义里(比如.proto文件)
当一个协议被编码的时候，key-value被一起编码进一个字节流里。当协议被解码的时候，解码器需要能够跳过它不能识别的成员。所以，新的成员变量可以不影响那些不需要知道新成员的旧程序（即兼容旧版本）。所以每一对key-value里的key包含两个含义-.proto配置文件里的成员编号，加上用来标识压缩类型来找出成员字段的长度。在大多数语言中，这个key称为标记。

数据类型如下:

| 类型   | 意义               | 使用范围                                |
| ---- | ---------------- | ----------------------------------- |
| 0    | Varint           | int32,int64,uint32,uint64,enum,bool |
| 1    | 64-bit           | fixed64,sfixed64,double             |
| 2    | length-delimited | string,bytes                        |

数据流中的每一个key都是一个varint，包含了字段的编号和压缩类型(field_number << 3 | wire_type)，即第4位表明字段编号至最高位表示的是成员变量的编号,最低位表示的是wire_type。

再回头来看我们的150：
```
	08 96 01
```
首先08，第一个字段表示的是key
```
	0000 1000
```
最低位是0,表明这是个**Varints**编码，右移3个bit，得到的值是**1**，表明这是第一个成员变量

接着用**Varints**去解码,首先去掉**msb**，同时,msb是**1**表示还没到字段的边界，若是**0**，表明已经到了字段的边界:
```
	96 01 = 1001 0110 0000 0001
              =  000 0001  001 0110 (翻转成大端,并且去掉msb)
              =  128 + 16 + 4 + 2
              = 150
```

#### 更多的值类型
##### 有符号整形
在之前的章节，讨论的都是类型为0的**varints**的编码方式。然而，编码signed int与标准的int有很大的区别，特别是编码负数的时候。正如你看到的，负的int32或int64编码的时候，是编码成10个字节，被当成一个非常大的无符号整形数字。如果你使用有符号的类型，使用**ZigZag**效率更高。

**ZiaZag**将有符号的整形编码成无符号的整形，一个绝对值很小的数字(类似-1)可变长编码后也会很小。通过这种通过正负来回摆动的编码方式(ZigZag是蜿蜒的意思)，所以，-1被编码成1,1编码成2,-2编码成3。如下：

| 编码前有符号数 | 编码后 |
| -------------- | ------ |
| 0              | 1      |
| -1             | 1      |
| 1              | 2      |
| -2             | 3      |
| 214            | 428    |
| -214           | 427    |

负数是 abs(x) * 2 - 1
正数是 x * 2

通过移位运算(四个字节)是:
```
	(n << 1) ^ (n >> 31)
```

需要注意的是，第二个移位操作(n >> 31)部分-是一个算数移位。换句话来说，这个移位的结果，如果是整数的话，结果是全0,如果是负数的话，结果是1。
当sint32或者sint64被解析后，它的值将被解码回原来的那个有符号版本。


##### 非可变长类型(Non-varint Numbers)
非可变长版本是很简单的，双精度浮点型和固定长度的64字段(fixed64)是类型1,告诉解析器，这里有一个固定64bit长度的数据块要解读。相似的，单精度浮点型与固定长度的32字段(fixed32)是类型5。这两种类型也都是用小端次序来储存数据的。

##### 字符串(strings)
类型为2的编码（长度分割）意味着值是指明了接下去的变长数据的长度:
```
message Test2 {
  optional string b = 2;
}
```

将b设置成**testing**：
```
	12 07 (74 65 73 74 69 6e 67)
```
被括号包裹的数据是UTF-8编码下的**testing**。
key字段是0x12:
```
	0001 0010
        ---->1000
	即field为2,成员编号也是2
```
变长长度字段是0x07，表明后续有7个字节组成我们的**string**

#### 复合类型(Embedded Message)
下面给出一个复合类型的协议定义：
```
	message Test3{
		optional Test1 c = 3;
	}
```
这里的Test1其实就是第一个例子的协议结构体。在Test1里的值150,编码成复合类型是:
```
	1a 03 08 96 01	
```
可以看到，最后三个字节和在Test1里的例子一样（08 96 01），并且他们之前有一个数字3--复合类型与字符串（string wire type = 2）有着一样的编码方式。
备注:1a = 0001 1010(type=2 num=3)

#### 可选(optional)和重复(repeated)元素
如果一个proto2版本的协议有**repeated**元素(没有[packed=true]的选项)，编码后的协议会有0个或者多个拥有同样成员字段的num编号。这些重复的值不一定要连续排列，他们也可能被其他的值交错。解码的时候，repeated元素之间依然有序，但是与不同成员变量之间的顺序被打乱了。在proto3版本里，重复的成员字段使用**packed encoding**，你可以在下面的内容里了解到它。

对于proto3版本里的一个非重复成员字段，即proto2版本里的可选字段，编码后的协议可能有也可能没有一个包含成员字段num的key-value对。

正常来说，一个非重复(non-repeated)成员字段，不可能出现多个值。但是，解码器会支持这种多种值的情况。对于一个数字类型或字符串，如果相同的字段出现了多次，解码器会接受最后一次出现的值。对于复合类型的成员字段，解码器会融合多个值里的相同的字段，就像Message::MergeFrom方法--所有单个的值会被后续出现的字段替换，单个复合的消息会被融合，重复的字段(repeated)会被并联(叠加)在一起。这种解码规则，同时解码两个复合类型，与分别解码并融合两个解码结果有一样的输出结果，就像这样：
```
	MyMessage message;
	message.ParseFromString(str1 + str2);
```
等价于：
```
	MyMessage message2;
	message.ParseFromString(str1);
	message2.ParseFromString(str2);
	message.MergeFrom(message2);
```
这种属性一般来说是有用的，它可以允许你融合两个你甚至不知道类型的协议。


##### 封装可重复成员字段(Packed Repeated Fields)
2.1.0版本引入了packed repeated fields成员字段，repeated字段声明成[packed=true]。在proto3版本里，repeated是默认就声明的。这个选项有点像repeated fields，但是编码的方式不相同。一个packed repeated成员字段如果是空的话，并不会出现在编码后的字节流里。否则，所有的相同重复字段将会被封装成一个单独的key-value对，并用wire type 2标识(长度分隔length delimited)。每一个元素的编码方式和正常的是一样的，只是没有了key字段在它前面。

例如，假设成有这样一个协议:
```
	message Test4 {
	  repeated int32 d = 4 [packed=true];
	}
```

然后，将d字段重复赋值3,270和86942，编码后是这样：
```
	22        // key (field number 4, wire type 2)
	06        // payload size (6 bytes)有效长度
	03        // first element (varint 3)
	8E 02     // second element (varint 270)
	9E A7 05  // third element (varint 86942)
```
只有基本数据类型(使用变长编码的32位，64位数据类型)可以被声明成packed repeated

要提醒的是，尽管一个packed repeated字段有超过一对的key-value字段是没有必要的，但是编码器必须准备好这种多个key-value对的编码。在这种情况下，有效长度必须为累加起来。每一个key-value对都必须指明所有元素的数量。

pb的解码器必须能够解析repeated packed的协议，就像他们没有被标记为packed一样，反之依然。这允许添加[packed=true]在现有成员字段后依然向前向后兼容。

#### 成员字段的顺序
尽管可以在.proto配置任意顺序,但是一个协议在被序列化成已知的成员变量的时候，需要按顺序写入，在C++,Java,Python序列化代码里，都是如此。这些优化需要依赖成员字段的num按顺序分配。当然，pb的解码器需要能够解析以任意顺序编码的字节流，因为不是所有的协议都是简单的序列化一个对象--例如，有时候直接融合两个协议是非常有用的。

如果一个协议有未知字段，当前Java和C++的实现是在已知有序字段后随机写入，在当前的Python版本里丢弃未知字段。

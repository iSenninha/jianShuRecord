### 泛型

>泛型是为了在编译的时候就检查限制住某个对象的**类型**，即在编译的时候就进行类型检查，避免在**运行**的时候再发现类型不匹配。

- 泛型用例的标准参考：
  - E：元素
  - K：键
  - V：值
  - T：类型
  - N：数字
  - S，U：多参数情况下的第2，3个参数
  - 其他大写字母来代表其实也是可以的。

---

- 泛型如何使用

  泛型是使用在一个类名后，使用**尖括号<>**，里面写上我们需要的泛型，如下：

  ```java
  public class Generics<T> {
  }
  ```

  如何使用呢？假设Generics里面需要保存一个对象，就想象成这是一个可以保存任意一个对象的对象**容器**吧，那么代码变为如下：

  ```java
  public class Generics<T> {
  	private Object obj;
  }
  ```

  以上的写法是可以**储存**任意一种类型的对象，但是可能会导致，储存的人存的是**String**，但是取的人认为是**Integer**，然后在类型强转的时候就报错了。

  使用泛型就能优雅地解决这个问题：

  ```java
  public class Generics<T> {
  	private T t;
  }
  ```

  这个时候，我们初始化这个Generics的时候，就可以通过指定储存什么类型的对象来做到在编译的时候就做到类型检查:

  ```java
  public class Generics<T> {
  	private T t;

  	public T getT() {
  		return t;
  	}
  	public void setT(T t) {
  		this.t = t;
  	}
  	
  	public static void main(String[] args) {
  		//优雅地保存这个变量
  		Generics<String> g = new Generics<>();
  		g.t = "";
  	}
  }
  ```

---

以上的例子应该很好地解释了如何使用泛型，并且泛型的使用场景，还有更多的使用方式，如下：

- 限制泛型中可指定的内容范围

  ```java
  import java.util.List;

  public class Generics<T extends List<String>> {
  	T list;
  	public static void main(String[] args) {
  		Generics<List<String>> g = new Generics<>();
  	}
  }
  ```

  这样就限制住了，必须是List的**子类**

- JDK中泛型的使用

  - List

    ```java
    public interface List<E> extends Collection<E>
    ```

  - Class

    ```java
    public final class Class<T>
    这个泛型是最有用的是用在newInstance()上：
    public T newInstance();
    直接指定了通过反射实例化一个对象返回的对象类型
    ```

---

总结：

泛型是在用在编译的时候进行类型检查的，编译完成后会替换成原型，比如**<T extends List>**，那么编译后就会替换成**List**，如果是**<T extends ?>**，那么编译后就会替换成**Object**。

通过在编译的时候检查，能更好地避免一下错误，使代码可读性更加高。
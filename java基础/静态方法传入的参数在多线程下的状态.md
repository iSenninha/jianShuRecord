###静态方法传入的参数在多线程下的状态

静态方法的传入的参数在多线程环境会会不会互相干扰呢，比如：
```
	public static void test(String test){
		System.out.println(test)
	}
```

如果同时有多个线程使用这个静态方法，这里的字符串test在多线程环境下还会是当时传入的那个参数吗？

猜测是不会影响的。。这个是引用传递

代码里来试试:

```
/*
*这里静态方法里有一个String类型的参数，两个线程同时进行，传入不同的*String对象，然后让一个线程等待1s，打印结果
*/
public class StaticMethodTest implements Runnable{
	static int i = 0;
	
	@Override
	public void run() {
		// TODO Auto-generated method stub
		//随机生成字符串
		testStaticMethod(Math.random()+ "");
	}
	
	public static void testStaticMethod(String s){
			System.out.println(Thread.currentThread().getName() + ":hello");
		if(i == 0){
			i = 1;
			try {
				//如果是第一个线程进来，让它休息1s
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}
		//打印出这时候引用的s是否不受影响
		System.out.println(Thread.currentThread().getName() + s);
	}


	
		public static void main(String[] args) {
		// TODO Auto-generated method stub
		StaticMethodTest t0 = new StaticMethodTest();
		StaticMethodTest t1 = new StaticMethodTest();
		new Thread(t0,"t0").start();
		new Thread(t1,"t1").start();
	}

}
```

运行结果：
```
t1:hello
t0:hello
t00.3163063185891368
t10.861889330531942
```

结果分析:
这场t1线程先进入，然后等待1s
t0进入后不用等待马上打印出字符串
t1等待后打印出字符串，和t0的字符串不是同一个。

这说明不受影响

结论：
静态方法传入的参数是在多线程中是不会相互影响的，因为是引用传递，引用或者修改的只是当时传入的那个参数所指向的内存空间

### Mysql锁

> 数据库的数据也必然是存在竞争的，所以也需要**锁**来协调竞争
>
> Mysql的锁是根据不同的数据库引擎而不同的。这里主要介绍**MyISAM**和**Innodb** 

- MyIsam

> MyIsam提供的是**表级锁**，这里的表级锁有读锁和写锁模式，和JDK的**ReentrantReadWriteLock**的原理类似。
>
> 不同之处是**如果多个读写锁同时在等待**，那么会偏向于让**写锁**先获取资源去执行，这里和[JDK的读写锁](../JUC源码学习/ReentrantReadWriteLock源码学习.md)不同之处

	##### 	那么如何加锁呢？

> 如下：
>
> ```
> Lock tables table_name read local;
> 1.首先，MyIsam在获取锁的时候会获取到所有本次查询需要的锁资源;
> 2.其次，这里加上local，是为了在满足并发操作的情况下，可以在表尾部插入新的资源
> Unlock tables;
> ```
>
> 如果不显示指定锁，那么



- Innodb

> **Innodb**和Myisam的主要区别是支持事务和支持行级锁

​	1.观察行级锁的竞争情况

> ```
> show status like 'innodb_row_lock%';
> +-------------------------------+-------+
> | Variable_name                 | Value |
> +-------------------------------+-------+
> | Innodb_row_lock_current_waits | 0     |
> | Innodb_row_lock_time          | 1     |
> | Innodb_row_lock_time_avg      | 0     |
> | Innodb_row_lock_time_max      | 0     |
> | Innodb_row_lock_waits         | 3     |
> +-------------------------------+-------+
> 5 rows in set (0.00 sec)
> ```

​	2.行级锁的分类

>  共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
>
>  排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
>
> 另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。
>
> 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
>
> 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

​	3.如何使用行级锁

> 只要在sql后加LOCK IN SHARE MODE 或FOR UPDATE
>
> ```
> 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
> 排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE
> ```
>
> 这样加的锁会持续到本次事务结束

​	4.锁的实现

>  InnoDB行锁是通过索引上的索引项来实现的，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者：只有通过**索引**条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！

​	5.间隙锁

> ​    当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制不是所谓的间隙锁（Next-Key锁）。
>
> ​    举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101，下面的SQL：
>
> `SELECT * FROM emp WHERE empid > 100 FOR UPDATE`
>
> ​    是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。
>
> ​    InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。
>
> ​    很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。
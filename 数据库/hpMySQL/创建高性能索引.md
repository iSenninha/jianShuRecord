### 创建高性能索引

[TOC]

> Mysql的索引是在储存引擎层实现的，所以我们讨论索引是要结合不同的储存引擎去讨论的。这里我们学习一下InnoDB和MyISAM在索引上实现的异同。
首先，索引使用的结构我们姑且叫它BTree，尽管他们真正使用的数据结构可能不是它。

#### 使用数据结构的异同
- InnoDB和MyISAM都是使用B-tree作为索引的数据结构。
- 相同点在于主键索引都在叶子节点上，不同点在于InnoDB是聚族索引，直接把数据也存在B-tree解构上。而MyISAM则是指向对应的数据行。另外MyISAM还使用了压缩索引。
- 对于非主键索引的情况,MyISAM索引指向的是数据行的指针，而InnoDB指向的是主键，索引需要二次索引才能找到数据。好处则是在移动行数据的时候，无需更新这个非主键索引。

#### 主键选择
由于InnoDB聚族索引的特性，所以，主键最好是连续增加的，而不是随机分布的，因为这将会导致插入变得完全随机。插入完全随机，将导致每一次插入都要为新行寻找合适的位置--通常这个位置已经有了其他数据，那么就需要重新分配空间，并移动数据。这写都将导致性能的消耗。
但是，如果选择了自增作为主键，在高并发情况下可能会导致间隙锁的竞争，主键的分配成为性能的瓶颈。

#### 覆盖索引
所谓覆盖索引，其实就是多个联合索引，并且查询所需要的数据都联合索引里面，那么一次查询，就可以获取到所有的数据，不需要去查找对应的数据行。
需要注意以下的点：
- 不要在where条件中进行计算（这也是使用索引的规矩）;
- 不要使用类似** like '%xxx'**，这将导致索引完全失效；

#### 使用索引来排序
由于索引的是按顺序的，所有，我们的排序规则与索引的顺序规则是一致的话(与索引逆序也没关系），就不用在服务器层对查询得到的数据再次进行排序。
需要注意的是，如果是多个order规则，order的顺序需要与创建联合索引的顺序一致。

#### 压缩(前缀)索引
MyISAM压缩索引的方法是，扫描每一个块的第一个索引的值，如：senninha，然后第二个索引senninhahaha，记为8,haha这样，能有效压缩储存空间，但是也会使得性能下降

#### 索引与锁
使用索引可以锁定更少的行，但是仍然无法避免锁住无关的行。如下：
```
	set autocommit = 0;
	begin;
	select * from example where id > 1 and id < 3 for update;
```
实际上，这条语句会锁住id > 1的所有行，储存引擎并不知道id < 3这个条件，这个时候，在另外一个会话中访问id = 3（本不该被锁住的行）仍然会阻塞。
在MySql5.1以及更新的新版本中，服务器层检查到不需要的行会在事务提交前释放锁。

#### 分页与索引
有时候，我们需要对数据进行分页，但是，如果页数过多，比如**limit 100 000 000, 10**，如果直接扫描行，将会导致扫描大量不需要的行，我们可以通过建立联合索引，使其只扫描较轻巧的索引，获取需要的主键，再去获取对应的行数据。
```
	select * from example where id in (select id from example order by id limit 100 000 000,10;
```

#### 索引需要注意的事项
- 单行访问是很慢的，尽可能在一次载入尽量多的数据;
- 顺序访问是很快的，可以减少io和避免排序;
- 覆盖索引是很快的，不需要进行二次索引查找行数据。
